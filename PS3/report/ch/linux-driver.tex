\subsection{Linux Driver}
In linux/Unix nearly everything is represented as files. This also involves device drivers. The interaction with the drivers occurs by reading/writing to this file. More specific the drivers is accessed  using common functions for I/O. Each driver file is identified by a unique number, which allows the system to know the type of the file. More precisely, the drivers is identified based on two numbers, \emph major and \emph minor. The major number is used to defer to the device driver being used. All devices controlled by the same device driver has the same device number. The minor numbers are used to distinguish between different devices and their controllers. 



{\bf device number registration}


{\bf Configuring the file\_operation structure. Set of file pointers that defines the operations of the device driver. They are mostly responsible for creating system calls. "We can consider the file to be an "object" and the functions operating on it to be its "methods". "}



{\bf the kernel uses structures of type struct cdev to represent char devices internally. Before the kernel invokes your devices operations, you must allocate and register one or more of these structures}


User mode is unable to access the memory of kernel directly so special functions are needed to transfer data from/to kernel mode to user space.





Making the driver visible to user space. User programs communicate with the driver opening the driver file in the /dev/ folder. With this file the user program can interact with the driver. To make the driver appear in the /dev/ directory, the functions class\_create(...) and device\_create must be called. 


The memory of the microcontroller is memory-mapped. This implies that techniques regarding virtual memory is ignored. The driver is developed for working with the gamepad for this specific micro controller. 

\subsection{Input Handling}
The compendium describes three different ways of implementing the input handling from the gamepad. This methods represent different degree of technical difficulty and efficiency. For completeness all of these methods have been implemented following an iterative approach of learning. E.g start simple and extend it to more advanced techniques as the code is confirmed to work. 

The different approaches have dedicated sections explaining the techniques used. The techniques are realised by implementing different versions of I/O operations in the file.  

\subsubsection{Polling}


\subsubsection{Half Interrupt}


\subsubsection{Full interrupts}

