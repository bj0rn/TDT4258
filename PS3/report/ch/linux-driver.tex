\subsection{Linux Driver}
Interface between kernel and modules. In order initialise and de-initalize the driver the kernel need to implement two functions, one init function and one exit function. These functions are called when the module is loaded and un-loaded, respectively. The init function sets up everything necessary to load the module. The exit function de-allocate everything allocated in the init function. 

The following steps are taken in order to initialize the driver:

\begin{enumerate}
    \item Make the driver as a kernel module.
    \item Allocate and memory map access to the I/O hardware registers which will be used. 
    \item Initialize hardware
    \item Allocate character device structure. 
    \item Activate the driver.
\end{enumerate}

In linux/Unix nearly everything is represented as files. This also involves device drivers. The interaction with the drivers occurs by reading/writing to this file. More specific the drivers is accessed  using common functions for I/O. Each driver file is identified by a unique number, which allows the system to know the type of the file. The number is split into a \emph major and \emph minor number. The major number is used to defer to the device driver being used. All devices controlled by the same device driver has the same device number. The minor numbers are used to distinguish between different devices and their controllers. The first thing we do is allocate a MAJOR and MINOR number for the device driver. The function $alloc\_chrdev\_region()$ is used to allocate this dynamically. This function dynamically chooses the major number. The minor number is set to 0, since we only use one device. The use of minor number would be more relevant if we had several devices using the same driver. 

By now we have reserved some device numbers, but we have not connected any operations to those numbers. The next step consists of activating the char device structure. The file operation structure is initialised with all the functions that is to be supported by the kernel module. Each field in the structure points to the function in the driver that implements the specific operation. The initialization of the structure can be seen in code listing ??. {\bf create code listing}.

The kernel uses structures of type struct cdev to represent char devices internally in the kernel. Before we can invoke any device operations we need to represent the operations internally in the kernel. This is accomplished by using the $cdev\_intit()$ function. This takes the file\_operation structure as parameter and initialises the cdev structure needed for representing the char driver. The next step involves registering the device to the kernel by adding the cdev structure to the kernel. This is accomplished using the following function, $cdev\_add()$. This function registers the driver to the kernel module. {\bf more explicit} We have now completed the first step in initializing the driver. 















  





%User mode is unable to access the memory of kernel directly so special functions are needed to transfer data from/to kernel mode to user space.





%Making the driver visible to user space. User programs communicate with the driver opening the driver file in the /dev/ folder. With this file the user program can interact with the driver. To make the driver appear in the /dev/ directory, the functions class\_create(...) and device\_create must be called. 


%The memory of the microcontroller is memory-mapped. This implies that techniques regarding virtual memory is ignored. The driver is developed for working with the gamepad for this specific micro controller. 

\subsection{Input Handling}
The compendium describes three different ways of implementing the input handling from the gamepad. This methods represent different degree of technical difficulty and efficiency. For completeness all of these methods have been implemented following an iterative approach of learning. We started simple with polling and worked ourself up to the more advanced features like interrupts.  

The different approaches have dedicated sections explaining the techniques used. The techniques are realised by implementing different versions of I/O operations in the file.  

\subsubsection{Polling}


\subsubsection{Half Interrupt}


\subsubsection{Full interrupts}

