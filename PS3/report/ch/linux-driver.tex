\subsection{Linux Driver}
Interface between kernel and modules. In order initialise and de-initalize the driver the kernel need to implement two functions, one init function and one exit function. These functions are called when the module is loaded and un-loaded, respectively. The init function sets up everything necessary to load the module. The exit function de-allocate everything allocated in the init function. 

The following steps are taken in order to initialize the driver:

\begin{enumerate}
    \item Make the driver as a kernel module.
    \item Allocate character device structure and register the device. 
    \item Making the driver visible for user space.
    \item Allocate and memory map access to the I/O hardware registers which will be used. 
    \item Initialize hardware
\end{enumerate}

{\bf modify this list}

In linux/Unix nearly everything is represented as files. This also involves device drivers. The interaction with the drivers occurs by reading/writing to this file. More specific the drivers is accessed  using common functions for I/O. Each driver file is identified by a unique number, which allows the system to know the type of the file. The number is split into a \emph major and \emph minor number. The major number is used to defer to the device driver being used. All devices controlled by the same device driver has the same device number. The minor numbers are used to distinguish between different devices and their controllers. The first thing we do is allocate a MAJOR and MINOR number for the device driver. The function $alloc\_chrdev\_region()$ is used to allocate this dynamically. This function dynamically chooses the major number. The minor number is set to 0, since we only use one device. The use of minor number would be more relevant if we had several devices using the same driver. 

By now we have reserved some device numbers, but we have not connected any operations to those numbers. The next step consists of activating the char device structure. The file operation structure is initialised with all the functions that is to be supported by the kernel module. Each field in the structure points to the function in the driver that implements the specific operation. The initialization of the structure can be seen in code listing ??. {\bf create code listing}.

The kernel uses structures of type struct cdev to represent char devices internally in the kernel. Before we can invoke any device operations we need to represent the operations internally in the kernel. This is accomplished by using the $cdev\_intit()$ function. This takes the file\_operation structure as parameter and initialises the cdev structure needed for representing the char driver. The next step involves registering the device to the kernel by adding the cdev structure to the kernel. This is accomplished using the following function, $cdev\_add()$. This function registers the driver to the kernel module. {\bf more explicit} 

The next step is making the driver visible for user space. User space programs communicate with the driver by opening a special file in the /dev directory. In order to make this possible we must make the driver visible in this directory. This is accomplished by using two functions, $class\_create()$ and $device\_create()$. This functions create a device node. The first function initializes the class structure for the dev node. The second function creates a device and registers it with \emph sysfs. \emph Sysfs is a virtual file system in linux. Sysfs exports information about devices and drivers from the kernel to user space. 


The next step involves configuring the access to the gamepad controller. This involves configuring the GPIO pins of the development board by writing to the GPIO registers. However, before configuring GPIO we need to make sure that we have exclusive access to these registers. In this application this is not really necessary, but it is consider good practice. This is accomplished by requesting the memory region where the GPIO registers are located. Note that the memory is memory-mapped. For this purpose we use the function $request\_mem\_region()$. This ensures that the drivers as exclusive access to the memory locations occupied by the GPIO registers. Then we can start configuring the GPIO registers. However, we cannot configuring them directly like we did in exercise 1 and 2. For the purpose we writing and reading I/O registers we need to use a set of wrapper functions, provided by the kernel, $ioreadXX()$ and $iowriteXX()$. The write function takes the address and value as argument, while the read function takes the address. 





\subsection{Input Handling}
The compendium describes three different ways of implementing the input handling from the gamepad. This methods represent different degree of technical difficulty and efficiency. For completeness all of these methods have been implemented following an iterative approach of learning. We started simple with polling and worked ourself up to the more advanced features like interrupts.

The different approaches have dedicated sections explaining the techniques used. The techniques are realised by implementing different versions of I/O operations in the device driver, and further modifications. The modifications applied would be throughly explained in the following sections. 


\subsubsection{I/O operations}
In order for the driver to work when file operations are performed on the driver file we need to implement a set of I/O operations at the driver side. This involves implementing the functions that are seen in listing ??. These functions will from this point be referred to as system calls. They are called when the program in user space performs I/O operations on the driver file. These operations are as follows: {\bf add code listing}

Open is the first function that is called when interacting with the driver. The driver is not required to implement this function. If the function does not exist, opening the file will always succeed, but the driver is is not notified. In case of the gamepad driver this function only contain a print statement notifying that the file is opened. The close function is implemented in the same manner, just notifying that the file is closed. 

The \emph read function is used to retrieve data from the device driver. This function needs to return the information from the GPIO button registers. This is accomplished by reading the $GPIO\_PC\_DIN$ register. This register is 32-bit and contains the status of the buttons. However, the status just read resides in kernel mode so we need to transfer the data to user mode. We use the function, $copy\_to\_user()$, in order to transfer the button status to user mode. Since we are only interested in the higher 8-bits of the GPIO register we only need to transfer one byte. This byte contains sufficient information to determine the status of the buttons. 

The \emph write function is used to send data to the device. Since the gamepad driver does not need any information from user space this function does not need to be implemented. 



%\begin{itemize}
%    \item {$static int open_driver(struct *inode, struct file *filp)$}
%    \item {$static int release\_driver(struct inode *inode, struct  file *filp)$}
%    \item {$static ssize_t read\_driver(struct file *filp, char __user *buf, size_t count, loff_t *offp)$}
%    \item {$static ssize_t write\_driver(struct file *filp, const char __user *buf, size_t count, loff_t *offp)$}
%\end{itemize}



  



\subsubsection{Polling}
Polling is the simplest approach in developing and interacting with the driver. With polling, the user application continuously reads the driver through devnode. Each time the driver is polled, it reads the buttons and returns them to the user application. The problem with this method however is that the button status does not change that often implying waste of resources. A far better approach is utilising interrupts. 


\subsubsection{Half Interrupt}
The driver handles interrupts and copies the content of the GPIO register into a memory location reachable though the {\emph devnode}. The user application polls the driver and reads the data from the devnode. This method is still quite inefficient, but introduces new concepts that we can further improve to achieve higher efficiency. 

In order to achieve interrupts at the driver side we need to change the initialization of the gamepad driver. In particular, we need to configure interrupts both in the kernel and on the development board itself. An interrupt is simply as signal sent by the hardware device when it needs the CPUs attention. In linux interrupts are handled by registering a handler for the device's interrupt and handle them properly when they occur. 

The configuring of interrupts on the hardware levels in achieved in much the same way we are used to 
in exercise 1 and 2. But we need to keep in mind that it is not enough to generate interrupts only at the hardware level. We need to actually "see" that these interrupts are generated, so the software layer must be configured to. The kernel keeps a registry of interrupt lines similar to what we are used to in the microcontroller. "A module is expected to request an interrupt channel before using it and to release it when finished. This is accomplished with the two functions: $request\_irc()$ and $free\_irc$. The first function registers the interrupt to the kernel while the second removes the registration. 

One of the most challenging thing of registering interrupts can be how to determine the IRQ line that is going to be used by the device. The driver needs this information in order to correctly install the handler. Fortunately, this is already done for us in the compendium. From here we see that the handler for {\emph even} and {\emph odd} numbers are located at 17 and 18, respectively. From here it easy to register an interrupt handler for these interrupt lines. For completeness the code for activating interrupts can be seen in code listing ??.


Here we see that we register the interrupt handler $GPIO\_interrupt\_handler$ to listen to interrupts from {\emph even} and {\emph odd} pins. We also see that we pass the necessary information to reserve this lines for this specific driver. With this configuration we are able to sense interrupts at the kernel level. It is easy to confirm that interrupts does in fact occur by just printing a message when an interrupt occurs in the interrupt handler. However, keep in mind that the interrupt must be cleared by writing to the $GPIO\_IFC$ register. Failing to do so will cause a continous calls to the interrupt handler. Know when an interrupt occur we can write some small logic that reads the button status and store it. Then the user program can poll the driver to get the button status. 


\subsubsection{Full interrupts}



