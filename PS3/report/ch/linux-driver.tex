\subsection{Linux Driver}
Interface between kernel and modules. In order initialise and de-initalize the driver the kernel need to implement two functions, one init function and one exit function. These functions are called when the module is loaded and un-loaded, respectively. The init function sets up everything necessary to load the module. The exit function de-allocate everything allocated in the init function. 


\subsubsection{Initialization of the driver}

The following steps are taken in order to initialize the driver:

\begin{enumerate}
    \item Make the driver as a kernel module.
    \item Allocate character device structure and register the device. 
    \item Making the driver visible for user space.
    \item Allocate and memory map access to the I/O hardware registers which will be used. 
    \item Initialize hardware
\end{enumerate}

{\bf modify this list}

In linux/Unix nearly everything is represented as files. This also involves device drivers. The interaction with the drivers occurs by reading/writing to this file. More specific the drivers is accessed  using common functions for I/O. Each driver file is identified by a unique number, which allows the system to know the type of the file. The number is split into a \emph major and \emph minor number. The major number is used to defer to the device driver being used. All devices controlled by the same device driver has the same device number. The minor numbers are used to distinguish between different devices and their controllers. The first thing we do is allocate a MAJOR and MINOR number for the device driver. The function $alloc\_chrdev\_region()$ is used to allocate this dynamically. This function dynamically chooses the major number. The minor number is set to 0, since we only use one device. The use of minor number would be more relevant if we had several devices using the same driver. 

By now we have reserved some device numbers, but we have not connected any operations to those numbers. The next step consists of activating the char device structure. The file operation structure is initialised with all the functions that is to be supported by the kernel module. Each field in the structure points to the function in the driver that implements the specific operation. The initialization of the structure can be seen in code listing \ref{code:struct}. 

\begin{lstlisting}[caption=file operations, label=code:struct]
static struct file_operations fops = {
    .owner = THIS_MODULE,
    .read = read_driver,
    .write = write_driver,
    .open = open_driver,
    .release = release_driver,
    .fasync = driver_fasync,
};
\end{lstlisting}




The kernel uses structures of type struct cdev to represent char devices internally in the kernel. Before we can invoke any device operations we need to represent the operations internally in the kernel. This is accomplished by using the $cdev\_intit()$ function. This takes the file\_operation structure as parameter and initialises the cdev structure needed for representing the char driver. The next step involves registering the device to the kernel by adding the cdev structure to the kernel. This is accomplished using the following function, $cdev\_add()$. This function registers the driver to the kernel module. {\bf more explicit} 

The next step is making the driver visible for user space. User space programs communicate with the driver by opening a special file in the /dev directory. In order to make this possible we must make the driver visible in this directory. This is accomplished by using two functions, $class\_create()$ and $device\_create()$. This functions create a device node. The first function initializes the class structure for the dev node. The second function creates a device and registers it with \emph sysfs. \emph Sysfs is a virtual file system in linux. Sysfs exports information about devices and drivers from the kernel to user space. 


The next step involves configuring the access to the gamepad controller. This involves configuring the GPIO pins of the development board by writing to the GPIO registers. However, before configuring GPIO we need to make sure that we have exclusive access to these registers. In this application this is not really necessary, but it is consider good practice. This is accomplished by requesting the memory region where the GPIO registers are located. Note that the memory is memory-mapped. For this purpose we use the function $request\_mem\_region()$. This ensures that the drivers as exclusive access to the memory locations occupied by the GPIO registers. Then we can start configuring the GPIO registers. However, we cannot configuring them directly like we did in exercise 1 and 2. For the purpose we writing and reading I/O registers we need to use a set of wrapper functions, provided by the kernel, $ioreadXX()$ and $iowriteXX()$. The write function takes the address and value as argument, while the read function takes the address. 



\subsubsection{Cleaning up after the driver}
The exit function is called when the module stops being used. In this step we need to deallocate everything initialized in the init function. In particular we need de-allocate every structure used, and free every resource reserved by the driver. 






\subsection{Input Handling}
The compendium describes three different ways of implementing the input handling from the gamepad. This methods represent different degree of technical difficulty and efficiency. For completeness all of these methods have been implemented following an iterative approach of learning. We started simple with polling and worked ourself up to the more advanced features like interrupts.

The different approaches have dedicated sections explaining the techniques used. The techniques are realised by implementing different versions of I/O operations in the device driver, and further modifications. The modifications applied would be throughly explained in the following sections. 


\subsubsection{I/O operations}
In order for the driver to work when file operations are performed on the driver file we need to implement a set of I/O operations at the driver side. This involves implementing the functions that are seen in listing \ref{code:struct}. These functions will from this point be referred to as system calls. They are called when the program in user space performs I/O operations on the driver file. These operations are as follows: 

\begin{lstlisting}[caption=System calls, label=code:func]
static int open_driver(struct inode *node, struct file *filp){}

static int open_driver(struct inode *node, struct file *filp){}

static ssize_t read_driver(struct file *filp, char __user *buf, size_t count, loff_t *offp){}

static ssize_t write_driver(struct file *filp, const char __user *buf, size_t count, loff_t *offp){}

static int driver_fasync(int fd, struct file *filep, int mode){}
\end{lstlisting}




Open is the first function that is called when interacting with the driver. The driver is not required to implement this function. If the function does not exist, opening the file will always succeed, but the driver is is not notified. In case of the gamepad driver this function only contain a print statement notifying that the file is opened. The close function is implemented in the same manner, just notifying that the file is closed. 

The \emph read function is used to retrieve data from the device driver. This function needs to return the information from the GPIO button registers. This is accomplished by reading the $GPIO\_PC\_DIN$ register. This register is 32-bit and contains the status of the buttons. However, the status just read resides in kernel mode so we need to transfer the data to user mode. We use the function, $copy\_to\_user()$, in order to transfer the button status to user mode. Since we are only interested in the higher 8-bits of the GPIO register we only need to transfer one byte. This byte contains sufficient information to determine the status of the buttons. 

The \emph write function is used to send data to the device. Since the gamepad driver does not need any information from user space this function does not need to be implemented. The fasync function is discussed in greater detail when discussing asynchronous notifications. 




\subsubsection{Polling}
Polling is the simplest approach in developing and interacting with the driver. With polling, the user application continuously reads the driver through devnode. Each time the driver is polled, it reads the buttons and returns them to the user application. The problem with this method however is that the button status does not change that often implying waste of resources. A far better approach is utilising interrupts. 


\subsubsection{Half Interrupt}
The driver handles interrupts and copies the content of the GPIO register into a memory location reachable though the {\emph devnode}. The user application polls the driver and reads the data from the devnode. This method is still quite inefficient, but introduces new concepts that we can further improve to achieve higher efficiency. 

In order to achieve interrupts at the driver side we need to change the initialization of the gamepad driver. In particular, we need to configure interrupts both in the kernel and on the development board itself. An interrupt is simply as signal sent by the hardware device when it needs the CPUs attention. In linux interrupts are handled by registering a handler for the device's interrupt and handle them properly when they occur. 

The configuring of interrupts on the hardware levels in achieved in much the same way we are used to 
in exercise 1 and 2. But we need to keep in mind that it is not enough to generate interrupts only at the hardware level. We need to actually "see" that these interrupts are generated, so the software layer must be configured to. The kernel keeps a registry of interrupt lines similar to what we are used to in the microcontroller. "A module is expected to request an interrupt channel before using it and to release it when finished. This is accomplished with the two functions: $request\_irc()$ and $free\_irc$. The first function registers the interrupt to the kernel while the second removes the registration. 

One of the most challenging thing of registering interrupts can be how to determine the IRQ line that is going to be used by the device. The driver needs this information in order to correctly install the handler. Fortunately, this is already done for us in the compendium. From here we see that the handler for {\emph even} and {\emph odd} numbers are located at 17 and 18, respectively. From here it easy to register an interrupt handler for these interrupt lines. For completeness the code for activating interrupts can be seen in code listing \ref{code:interrupt}.

\begin{lstlisting}[caption=Activate interupts, label=code:interrupt]
request_irc(GPIO_EVEN_IRQ_NUM, (irq_handler_t)GPIO_interrupt_handler, 0, DRIVER, &driver_cdev);
request_irc(GPIO_ODD_IRQ_NUM, (irq_handler_t)GPIO_interrupt_handler, 0, DRIVER, &driver_cdev);

iowrite32(0x22222222, GPIO_EXTIPSELL);
iowrite32(0xff, GPIO_EXTIFALL);
iowrite32(0xff, GPIO_IEN);
\end{lstlisting}



Here we see that we register the interrupt handler $GPIO\_interrupt\_handler$ to listen to interrupts from {\emph even} and {\emph odd} pins. We also see that we pass the necessary information to reserve this lines for this specific driver. With this configuration we are able to sense interrupts at the kernel level. It is easy to confirm that interrupts does in fact occur by just printing a message when an interrupt occurs in the interrupt handler. However, keep in mind that the interrupt must be cleared by writing to the $GPIO\_IFC$ register. Failing to do so will cause a continuos calls to the interrupt handler. Know when an interrupt occur we can write some small logic that reads the button status and store it. Then the user program can poll the driver to get the button status. 


\subsubsection{Full interrupts}
To avoid polling altogether we can further develop the techniques discussed above. Instead of just handling the interrupt in the driver we need a way to notify the user program that an interrupt has occurred. By enabling asynchronous notifications the user program can receive signal whenever data becomes available and need not to use polling. This require some changes in the driver and some extensions in the user program. When adding support for asynchronous notification most of the work need actually to be done on the user side. In particular, the user program must register itself as a listener and create an signal handler that is executed when the program receives a signal. 

More precisely the user program need to perform the following steps in order to activate asynchronous notifications. First the program must specify itself as an "owner" of the file. "When a process invokes the F\_SETOWN command using the {\emph fcntl} system call, the process ID of the owner process is saved in the filp->owner for later use. This step is necessary for the kernel to know what process to notify. In order to actually enable asynchronous notification, the user programs must set the FASYNC flag in the device by means of the F\_SETFL {\emph fcntl} flag. After these two calls have been executed, the input file can request delivery of a SIGIO signal whenever new data arrives."

However, for this signal to be sent in the first place we need to modify the driver side as well. The driver must also implement asynchronous notification. Fortunately for us, this is quite simple. The linux kernel contains a set of functions to aid the implementation of asynchronous notification. "The general implementation offered by linux is based on one data structure and two functions." The data structure is of type $struct fasync\_struct$. This structured  is registered to the kernel by using a helper function, $fasync\_helper()$. This function is called when the user program sets the FASYNC flag. More precisely, we can say that this method is invoked to add or to remove entries from the list of interested processes when the FASYNC flag changes for an open file. This is implemented by adding a new function to the device driver that works as an wrapper around the helper function. This can be seen in code listing ??.

The signal themselves are sent to the user program by using the function, $kill\_fasync()$. When this function is executed all interested processes will receive an SIGIO signal. It arguments are signal to send (in this case SIGIO) and the band, which is POLL\_IN. The call to $kill\_fasync()$ is handled in the interrupt handler effectively ensuring that the user program receives a signal when the data changes, E.g the buttons are pushed. A code listing for the interrupt handler can be seen in listing ??.



 









