\subsection{Pong}
A pong game was developed in order to communicate with the gamepad driver. The game had to be kept relatively simple, as the resources on the EFM32GG-DK3750 are quite limited.

\subsubsection{Game description}

The concept of the game is simple: There are two paddles, each controlled by a player, and a ball moving back and forth. The leftmost paddle is controlled by player 1, and the rightmost paddle by player 2. If the ball collides with the wall, i.e. a player is not able to reach the ball with the paddle, the opposing player is awarded a point. The first player to reach 10 points wins. The code for the game is divided into two main files: display.c, which implements all the functions updating various parts of the display screen, and game.c, which contains the game logic as well as the main function loop for running the game.

As the main focus of this exercise is the devide driver, not too much focus is put on giving an in-detail description of the game implementation. Nonetheless, below is a brief description of the main parts of the game. Not too much emphasis is put on describing all the functions, as these are well commented with self-explanatory function and variable names in the attached code files.

\subsubsection{Game logic}

As mentioned, most of the game logic lies in the game.c-file. The functions in this file are responsible for opening the gamepad driver, handling gamepad input and updating the ball and paddle positions. This is done in the functions such as \emph{init_gamepad}, \emph{map_buttons}, \emph{move_ball} and \emph{move_paddle}. \emph{*intersect_rectangle_circle} is responsible for detection collisions between the ball and the paddles, and thus adjusting the direction and speed of the ball accordingly.

\subsubsection{Display logic}

The logic for updating the various parts of the display lies in the display.c-file. The idea is fairly simple: open the framebuffer driver (fb0) on initialization, and memory map the amount of screen bytes to an array with the use of the \emph{mmap}-function. Each pixel on the screen would then be represented by two bytes by using the RGB color model (with five, five, and six bits respectively). Writing a 16-bit RGB value to a position in the memory mapped array would then set the pixel to the appropriate color, and the screen would then be updated when refreshing the screen with the \emph{ioctl}-command. The paddles and ball are represented as structs with attributes such as length, height, and color. INSERT MORE ABOUT DRAWING FUNCTIONS.

\subsubsection{Images}




\subsubsection{Optimizations}

Circle drawing (8-way symmetry circle drawing algorithm)

Optimized screen update for paddels. Updates the screen partly. Interrupt based 
