\section{Description And Methodology}
This sections presents the description of the problem and the methodology. The initial setup of the micro controller regarding GPIO, buttons and LEDs are explained in section \ref{ch:initial_setup}. 


\subsection{GPIO clock setup} \label{ch:initial_setup}
The EFM32GG micro controller is memory mapped. I/O devices is accessed by reading and writing to specific memory locations. The CPU uses normal read and write instructions to communicate with the devices. Each I/O device is given a specific address in the memory map of the device. To save memory only the I/O controller used are clocked. This implies that the the I/O controller needs to be enabled before it can be used. Fortunately, the EFM32GG has a dedicated I/O controller for handling the different clocks, the clock management unit(CMU). A specific can be enabled by writing to the \emph CMU\_HFPERCLKEN0 register. This register consists of 32 bits where each bit correspond to an I/O controller. 

In case of interfacing the gamepad to the EFM32GG, the GPIO pins are used. These pins are controlled through the GPIO controller. To enable an I/O the clock of an I/0 controller simply write 1 to its corresponding position. In case of enabling the GPIO clock position 13 is written. The following instructions give an example how this can be achieved: 

\begin{lstlisting}
ldr r1, =CMU_BASE                //r1 = CMU_BASE
ldr r2, [r1, #CMU_HFPERCLKEN0]   //r2 = CMU_HFPERCLKEN0 

mov r3, #1                       //r3 = 1
lsl r3, r3, #CMU_HFPERCLKEN0_GPIO//Shift left 13 positions
orr r3, r2, r3                   //Enable the GPIO clock

str r2, [r1, #CMU_HFPERCLKEN0]   //Store the register back 
\end{lstlisting}


\subsection{LED setup}

The GPIO pins are divided into several different ports on the EFM32GG-DK3750 development board. Each port corresponds to a different location in memory.  The pins are configured by writing to the $GPIO\_MODEL$ and $GPIO\_MODEH$ registers. These can be accessed by using their position relative to the GPIO base to the specific port. These registers contains 8 bit fields that can be used to configure pins.  "$GPIO\_Px\_Model$ contains 8 bit fields named MODEn (n=0,1, .., 7) which controls pins 0-7 which controls pins 0-7, while $GPIO\_Px\_MODEH$ contains 8 bit fields named MODEn (n=8, 9, ..15) which controls pins 8-15." The different configurations can be found in \cite[p.758-759]{EFM32GG-rm}.    

In case of the gamepad controller the pins to the LEDs are connected to port A. These are assigned to output by writing {\emph 0x55555555} to  the $GPIO\_PA\_MODEH$ register. This corresponds to setting the pins 8-15 to an "open drain with pull-up" configuration\cite[p.758-759]{EFM32GG-rm}. This means that the transistors connect to low and the resistor connects to high. This is configuration specific to the gamepad controller, and can be viewed in the schematics of the gamepad\cite{compendium}. Additionally, the drive strength of the pins are set to high. This is the current capabilities of the device. This is accomplished by writing 0x02 to the $GPIO\_PA\_CTRL$ register. Now, it is possible to toggle the LEDs by writing writing 0 to the upper level of the $GPIO\_PA\_DOUT$ registers. Note that the responds to active low signals. This can be seen by the gamepad schematics\cite{compendium}. The following instructions give an example on how this can be achieved:


\begin{lstlisting}
ldr r1, =GPIO_PA_BASE        // r1 = GPIO_PA_BASE
ldr r2, =0x55555555          // r2 = 0x55555555  
str r2, [r1, #GPIO_MODEH]    //Store config
mov r2, #0x2                 // r2=0x02
str r2, [r1, #GPIO_PA_CTRL]  // GPIO_PA_CTRL=0x2                    

\end{lstlisting}


 

\subsection{Button setup}
The buttons are configured very similar with the configurations of the LEDs. However, with some differences. The buttons are configured by writing the configuration the $GPIO\_PC\_MODEL$ register. This register corresponds to pin numbers ranging from 0 to 7. The pins are set to input by writing {\emph 0x33333333} to the $GPIO\_PC\_MODEL$ register. This corresponds to configuring each pin to "open drain with alternating drive strength"\cite[p.758-759]{EFM32GG-rm}. The a internal pull-up is enabled by writing 
Then internal pull-up is enabled by writing 0xff to the $GPIO\_PC\_DOUT$ register. The state of the buttons can be read by reading the $GPIO\_PC\_DIN$. An example of the configuration can be viewed in the following code snippet. 

\begin{lstlisting}
ldr r1, =GPIO_PC_BASE        //r1 = GPIO_PC_BASE
ldr r2, =0x33333333          //r2 = 0x33333333  
str r2, [r1, #GPIO_MODEL]    //Store config
mov r2, #0xff                // r2 = 0xff
str r2, [r1, #GPIO_DOUT]     // Internal pull-up

\end{lstlisting}





\subsection{Polling}\label{ch:polling}
The simplest way of communicate with an I/O device is what is known as busy waiting\cite[p. ]{wolf}. In this scheme the CPU constantly checks the device to check if the state have changed. This is accomplished by polling some register to check whether the state has changed. In context of the gamepad this involves checking the status of the buttons. This can be accomplished by a loop continuously checking the  
the $GPIO\_PC\_DIN$ register. If one of the bits in range 0-7 is set, the button is pushed. Note that a button is active low. An example of polling is provided in the following code snippet:

\begin{lstlisting}
     ldr r1, =GPIO_PC_BASE   // r1 = GPIO_PC_BASE
     ldr r2, =GPIO_PA_BASE   // r2 = GPIO_PA_BASE
while:
    ldr r3, [r1, #GPIO_DIN]  // r3 = GPIO_PC_DIN
    lsl r3, r3, #8           // r3 = shift left 8  
    str r3, [r2, #GPIO_DOUT] // GPIO_PA_DOUT = r3
    b while                  // loop
\end{lstlisting}

In this code example the buttons are continuously polled. The result from the read is written to the $GPIO\_PA\_DOUT$ register. Since the buttons are located at the lower pins, and the buttons are located at the higher addresses, the value is shifted 8 positions to the left before it is written to the $GPIO\_PA\_DOUT$ register. 


\subsection{Interrupts}\label{ch:interrupts}
Continuously polling the status of some I/0 register is very inefficient. A lot of computational resources are wasted. A far better approach is to use interrupts. In interrupt the I/O controller is responsible of informing the CPU when change has occurred. When an interrupt occur the flow of execution is changed, and the CPU changes the program counter to point to an interrupt handler. The interrupt handler contains the code that should run in case of an interrupt. {\bf more details required}

In the EFM32GG with its ARM cortex-M3 processor contains an interrupt controller which can be used to enable and disable various interrupts. In the ARM cortex M3 micro processor this interrupt controller is known as the Nested Vectored Interrupt Controller(NVIC). This vector table contains the addresses of exception handlers and the Interrupt service routines (ISRs). In the ARM cortex M family of processors each Interrupt requests(IRQ) received has its own ISR. The starting address of each ISR is stored in an interrupt vector table (AN0039). 

The ISER0 and ISER1 registers enable interrupts, and show which interrupts are enabled(Cortex-m3 89). However, usually only one register is necessary: the ISERO contains one bit for each interrupt source.(compendium). In the cortex M3 there are two interrupt handlers that handles interrupts from even numbered GPIO-pins and odd numbered GPIO-pins. These can be located at position 1 and 11 in the ISER0. Since it is not useful to distinguish odd and even pins in this particular example, both will be enabled and lead to the same interrupt handler. This can be accomplished by writing 0x802, which corresponds to enable the interrupt handler for even and odd numbered pins.

The registers $GPIO\_EXTIPSELL$ or $GPIO\_EXTIPSELH$ is used to select which port will trigger the interrupt flag. These registers are organized such that all the the pins with the same number are grouped together. The $GPIO\_EXTIPSELL$ is responsible for the pins ranging from 0 to 7, and $GPIO\_EXTIPSELH$ are responsible for the pins ranging from 8 to 15. In each of these registers 3-bits are used to specify which port the should trigger the interrupt flag. An overview of the different ports can be found in section 32.5.10 in (EFM32GG reference). In order to sense the interrupt flag, the registers $GPIO\_EXTRISE$ and/or $GPIO\_EXTFALL$ needs to be set. These registers enable sensing of rising and falling edges, respectively. These can be enabled by writing 0xff to both $GPIO\_EXTIFALL$ and $GPIO\_EXTIRISE$.  To enable interrupt generation, 0xff is written to $GPIO\_IEN$. 


When an interrupt has occurred the interrupt flag is still set. In order to reset this flag the $GPIO\_IFC$ needs to be written. This register contains all the interrupt sources. An interrupt flag is reset by writing setting its corresponding bit to 0. The easiest way of achieving this is simply by reading the $GPIO\_IF$ register, which is containg the source of the interrupt. By writing this value to the $GPIO\_IFC$ register the flag will be cleared.  



If not, it will cause the interrupt handler to be called repeatedly. In order to reset the correct flag, the interrupt 



"The GPIO can generate an interrupt from the input of any GPIO pin on a device. The interrupts have asynchronous sense capability, enabling wake-up from energy modes as low as EM3" 


{\bf need more details here}


\subsection{Energy modes}\label{ch:energy_modes} 
The EFM32GG micro controller has rich set of features regarding improving energy efficiency. For instance the EFM32GG contains several different energy levels. Where each level corresponds to some features being turned off. The main idea behind improving energy efficiency is turning of components that are not in use, or when they are not needed. However, it is also possible to modify the components themselves to use less energy. For instance, the clock manager is very powerful and allows the code to scale the clock to different frequencies. It is also possible to setup different clocks for different purposes. It is also possible to turn off parts of the RAM in order to improve energy efficiency. {\bf not enough details}


When waiting for an interrupt to occur there is really nothing going on in the system. This makes it possible to enter deep sleep mode during this time. There no point in wasting energy while waiting for interrupts, the processor is idle any way. In order to save this energy, EFM32GG allows the micro controller to enter energy mode very easily. The EFM32GG is still able to handle interrupts during this time. By entering deep sleep mode stops the high frequency oscillators and the HFPERCLK/HFCORECLK as well as the flash memory(cite EFM32GG side 30). During deep sleep mode it is possible to achieve energy consumption as low as, 900 nA(cite EFM32 energy efficiency page 2). The CPU will wake up when it receive an interrupt and go back to sleep when it is finished handling the interrupt. It is able to wake up in only 2micro seconds. (same cite). This is very beneficial when considering energy efficiency.   

Entering deep sleep mode can be achieved by writing to the System Control Register(SCR). This register contains to bits of particular interest: \emph DEEPSLEEP and \emph SLEEPONEXIT. When enable, the DEEPSLEEP bit allows the CPU to enter deep sleep mode. SLEEPONEXIT, when enabled, allows the CPU to enter deep sleep mode when finished handling an interrupt. Both bits can be set by writing the value 6 to the \emph SCR register. When the \emph SCR register is configured, deep sleep mode can be achieved by calling the \emph WFI instructions. This instruction causes immediate entry to sleep mode. 


   

















