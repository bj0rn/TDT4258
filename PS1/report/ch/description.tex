\section{Description And Methodology}
This sections presents the description of the problem and the methodology. The initial setup of the micro controller regarding GPIO, buttons and LEDs are explained in section \ref{ch:initial_setup}. 


\subsection{Initial setup} \label{ch:initial_setup}
The EFM32GG micro controller is memory mapped. I/O devices is accessed by reading and writing to specific memory locations. The CPU uses normal read and write instructions to communicate with the devices. Each I/O device is given a specific address in the memory map of the device. To save memory only the I/O controller used are clocked. This implies that the the I/O controller needs to be enabled before it can be used. Fortunately, the EFM32GG has a dedicated I/O controller for handling the different clocks, the clock management unit(CMU). A specific can be enabled by writing to the \emph CMU\_HFPERCLKEN0 register. This register consists of 32 bits where each bit correspond to an I/O controller. 

In case of interfacing the gamepad to the EFM32GG, the GPIO pins are used. These pins are controlled through the GPIO controller. To enable an I/O the clock of an I/0 controller simply write 1 to it corresponding position. In case of enabling the GPIO clock position 13 is written. 

\begin{lstlisting}
ldr r1, =CMU_BASE #Load the base of the CMU
ldr r2, [r1, #CMU_HFPERCLKEN0] //Load the current value of HPERCLK ENBALE

mov r3, #1   //Move the constant one into register r3
lsl r3, r3, #CMU_HFPERCLKEN0_GPIO   //Shift left 13 positions
orr r3, r2, r3 //Enable the GPIO clock
str r2, [r1, #CMU_HFPERCLKEN0] //Store the register back 
\end{lstlisting}


The GPIO pins are divided into several different ports on the EFM32GG-DK3750 development board. Each port corresponds to a different location in memory. For each port there exist a set of special registers in order to configure the pins. These pins can be configured to be either input or output. Det input portion can be accessed by reading the $GPIO\_DIN$ register, output to the pins can be set by writing to the $GPIO\_DOUT$ register. 

However, before the pins can be used they need to be configured. In this particular case these leds are connected to port A through a ribbon cable. However, it does not matter where they are connected as long as their are configured correctly. The pins are configured by writing to the $GPIO\_MODEL$ and $GPIO\_MODEH$ registers. These can be accessed by using their position relative to the GPIO base to the specific port. "To use a specific pin, the port $GPIO\_Px\_MODEL/GPIO\_Px\_MODEH$ registers must be configured for the pin to make it input or output". The pins also be configured to more advanced features, $GPIO\_Px\_Modeln$ contains 8 bit fields that can be used to configure the pin. The overview of different configurations can be found in (EFM32GG reference page 758 - 759). "$GPIO\_Px\_Model$ contains 8 bit fields named MODEn (n=0,1, .., 7) which controls pins 0-7 which controls pins 0-7, while $GPIO\_Px\_MODEH$ contains 8 bit fields named MODEn (n=8, 9, ..15) which controls pins 8-15."  

In case with the gamepad controller the pins to the leds are assigned to be output by writing 0b1010 to the $GPIO\_PA\_MODEH$ register. This enables an "open drain with pull up" configuration. This means that the transistors connect to low and the resistor connect to high. This is just the a configuration specific to the gamepad controller. Additionally, the drive strength for the pins are set to to high. This is accomplished by writing 0x02 to the $GPIO\_PA\_CTRL$ register. Know it is possible to toggle the leds by writing writing 0 to the upper level of the $GPIO\_PA\_DOUT$ registers. Note that the LED are active low. This can be seen for the given schematics of the gamepad.   

The buttons are configured by enabling the lower pins of port C by writing 0b1100 to each pin using the $GPIO\_PC\_MODEL$ register. This implies that each pin is configured with an open drain with alternating drive strength. Then internal pull-up is enabled by writing 0xff to the $GPIO\_PC\_DOUT$. This make it possible to read the status of the buttons by reading the $GPIO\_PC\_DIN$ register. 



\subsection{Polling}\label{ch:polling}
The simplest way of communicate with an I/O device is what is known as busy waiting\cite{micro}. In this scheme the CPU constantly checks the device to check if the state have changed. This is accomplished by constantly checking if the value of some register has changed. In the context of the gamepad this involves checking the status of the buttons. If the button is toggled the program responds with performs by writing something to the LEDs. This is accomplished by reading the input registers of the buttons to check whether the buttons are pushed or not. 

In the case of the gamepad this can be accomplished by looping and continuously checking the $GPIO\_PC\_DIN$ register. If the returned register contains a 0, the button is pushed. To get some feedback on what buttons are pushed. The result from the read can be written to the $GPIO\_PA\_DOUT$ register. Since the buttons are located at the lower pins, and the buttons are located at the higher addresses, the value need to be shifted 8 positions to the left before it can be written to the $GPIO\_PA\_DOUT$ register. 

\subsection{Interrupts}\label{ch:interrupts}
Continuously polling the status of some I/0 register is very inefficient. A lot of computational resources are wasted. A far better approach is to use interrupts. In interrupt the I/O controller is responsible of informing the CPU when change has occurred. When an interrupt occur the flow of execution is changed, and the CPU changes the program counter to point to an interrupt handler. The interrupt handler contains the code that should run in case of an interrupt. {\bf more details required}

In the EFM32GG with its ARM cortex-M3 processor contains an interrupt controller which can be used to enable and disable various interrupts. In the ARM cortex M3 micro processor this interrupt controller is known as the Nested Vectored Interrupt Controller(NVIC). This vector table contains the addresses of exception handlers and the Interrupt service routines (ISRs). In the ARM cortex M family of processors each Interrupt requests(IRQ) received has its own ISR. The starting address of each ISR is stored in an interrupt vector table (AN0039). 

The ISER0 and ISER1 registers enable interrupts, and show which interrupts are enabled(Cortex-m3 89). However, usually only one register is necessary: the ISERO contains one bit for each interrupt source.(compendium). In the cortex M3 there are two interrupt handlers that handles interrupts from even numbered GPIO-pins and odd numbered GPIO-pins. These can be located at position 1 and 11 in the ISER0. Since it is not useful to distinguish odd and even pins in this particular example, both will be enabled and lead to the same interrupt handler. This can be accomplished by writing 0x802, which corresponds to enable the interrupt handler for even and odd numbered pins.

The registers $GPIO\_EXTIPSELL$ or $GPIO\_EXTIPSELH$ is used to select which port will trigger the interrupt flag. These registers are organized such that all the the pins with the same number are grouped together. The $GPIO\_EXTIPSELL$ is responsible for the pins ranging from 0 to 7, and $GPIO\_EXTIPSELH$ are responsible for the pins ranging from 8 to 15. In each of these registers 3-bits are used to specify which port the should trigger the interrupt flag. An overview of the different ports can be found in section 32.5.10 in (EFM32GG reference). In order to sense the interrupt flag, the registers $GPIO\_EXTRISE$ and/or $GPIO\_EXTFALL$ needs to be set. These registers enable sensing of rising and falling edges, respectively. These can be enabled by writing 0xff to both $GPIO\_EXTIFALL$ and $GPIO\_EXTIRISE$.  To enable interrupt generation, 0xff is written to $GPIO\_IEN$. 


When an interrupt has occurred the interrupt flag is still set. In order to reset this flag the $GPIO\_IFC$ needs to be written. This register contains all the interrupt sources. An interrupt flag is reset by writing setting its corresponding bit to 0. The easiest way of achieving this is simply by reading the $GPIO\_IF$ register, which is containg the source of the interrupt. By writing this value to the $GPIO\_IFC$ register the flag will be cleared.  



If not, it will cause the interrupt handler to be called repeatedly. In order to reset the correct flag, the interrupt 



"The GPIO can generate an interrupt from the input of any GPIO pin on a device. The interrupts have asynchronous sense capability, enabling wake-up from energy modes as low as EM3" 


{\bf need more details here}


\subsection{Energy modes}\label{ch:energy_modes} 
The EFM32GG micro controller has rich set of features regarding improving energy efficiency. For instance the EFM32GG contains several different energy levels. Where each level corresponds to some features being turned off. The main idea behind improving energy efficiency is turning of components that are not in use, or when they are not needed. However, it is also possible to modify the components themselves to use less energy. For instance, the clock manager is very powerful and allows the code to scale the clock to different frequencies. It is also possible to setup different clocks for different purposes. It is also possible to turn off parts of the RAM in order to improve energy efficiency. {\bf not enough details}


When waiting for an interrupt to occur there is really nothing going on in the system. This makes it possible to enter deep sleep mode during this time. There no point in wasting energy while waiting for interrupts, the processor is idle any way. In order to save this energy, EFM32GG allows the micro controller to enter energy mode very easily. The EFM32GG is still able to handle interrupts during this time. By entering deep sleep mode stops the high frequency oscillators and the HFPERCLK/HFCORECLK as well as the flash memory(cite EFM32GG side 30). During deep sleep mode it is possible to achieve energy consumption as low as, 900 nA(cite EFM32 energy efficiency page 2). The CPU will wake up when it receive an interrupt and go back to sleep when it is finished handling the interrupt. It is able to wake up in only 2micro seconds. (same cite). This is very beneficial when considering energy efficiency.   

Entering deep sleep mode can be achieved by writing to the System Control Register(SCR). This register contains to bits of particular interest: \emph DEEPSLEEP and \emph SLEEPONEXIT. When enable, the DEEPSLEEP bit allows the CPU to enter deep sleep mode. SLEEPONEXIT, when enabled, allows the CPU to enter deep sleep mode when finished handling an interrupt. Both bits can be set by writing the value 6 to the \emph SCR register. When the \emph SCR register is configured, deep sleep mode can be achieved by calling the \emph WFI instructions. This instruction causes immediate entry to sleep mode. 


   

















