\section{Description And Methodology}
This sections presents the description of the problem and the methodology. The initial setup of the micro controller regarding GPIO, buttons and leds are explained in section \ref{ch:initial_setup}. 




\subsection{Initial setup} \label{ch:initial_setup}
The EFM32GG micro controller is memory mapped. I/O devices is accessed by reading and writing to specific memory locations. The CPU uses normal read and write instructions to communicate with the devices. Each I/O device is given a specific address in the memory map of the device. To save memory only the I/O controller used are clocked. This implies that the the I/O controller needs to be enabled before it can be used. Fortunately, the EFM32GG has a dedicated I/O controller for handling the different clocks, the clock management unit(CMU). A specific can be enabled by writing to the \emph CMU\_HFPERCLKEN0 register. This register consists of 32 bits where each bit correspond to an I/O controller. 

In case of interfacing the gamepad to the EFM32GG, the GPIO pins are used. These pins are controlled through the GPIO controller. To enable an I/O the clock of an I/0 controller simply write 1 to it corresponding position. In case of enabling the GPIO clock position 13 is written. 

The GPIO pins are divided into several different ports on the EFM32GG-DK3750 development board. Each port corresponds to a different location in memory. For each port there exist a set of special registers in order to configure the pins. These pins can be configured to be either input or output. Det input portion can be accessed by reading the $GPIO_DIN$ register, output to the pins can be set by writing to the $GPIO_DOUT$ register. 

However, before the pins can be used they need to be configured. In this particular case these leds are connected to port A through a ribbon cable. However, it does not matter where they are connected as long as their are configured correctly. The pins are configured by writing to the GPIO\_MODEL and GPIO\_MODEH registers. These can be accessed by using their position relative to the GPIO base to the specific port. "To use a specific pin, the port GPIO\_Px\_MODEL/GPIO\_Px\_MODEH registers must be configured for the pin to make it input or output". The pins also be configured to more advanced features, GPIO\_Px\_Modeln contains 8 bit fields that can be used to configure the pin. The overview of different configurations can be found in (EFM32GG reference page 758 - 759). "GPIO\_Px\_Model contains 8 bit fields named MODEn (n=0,1, .., 7) which controls pins 0-7 which controls pins 0-7, while GPIO\_Px\_MODEH contains 8 bit fields named MODEn (n=8, 9, ..15) which controls pins 8-15."  

In case with the gamepad controller the pins to the leds are assigned to be output by writing 0b1010 to the GPIO\_PA\_MODEH register. This enables an "open drain with pull up" configuration. This means that the transistors connect to low and the resistor connect to high. This is just the a configuration specific to the gamepad controller. Additionally, the drive strength for the pins are set to to high. This is accomplished by writing GPIO\_PA_\CTRL register. 

The buttons are configured by enabling the lower pins of port C by writing 0b1100 to each pin using the GPIO\_PC_\MODEL register. This implies that each pin is configured with an open drain with alternating drive strength. Then internal pull-up is enabled by writing 0xff to the GPIO\_PC\_DOUT. 




\subsection{Polling}\label{ch:polling}
The simplest way of communicate with an I/O device is what is known as busy waiting\cite{micro}. In this scheme the CPU constantly checks the device to check if the state have changed. This is accomplished by constantly checking if the value of some register has changed. In the context of the gamepad this involves checking the status of the buttons. If the button is toggled the program responds with performs by writing something to the leds. This is accomplished by reading the input registers of the buttons to check whether the buttons are pushed or not. 

\subsection{Interrupts}\label{ch:interrupts}
Continuously polling the status of some I/0 register is very inefficient. A lot of computational resources are wasted. A far better approach is to use interrupts. In interrupt the I/O controller is responsible of informing the CPU when change has occurred. When an interrupt occur the flow of execution is changed, and the CPU changes the program counter to point to an interrupt handler. The interrupt handler contains the code that should run in case of an interrupt.  


\subsection{Energy modes}\label{ch:energy_modes} 





