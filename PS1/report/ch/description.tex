\section{Description And Methodology}

The following section explains the setup of the microcontroller regarding GPIO, buttons and LEDs step by step. \ref{ch:initial_setup}. 


\subsection{GPIO clock setup} \label{ch:initial_setup}
The EFM32GG microcontroller is memory mapped, and the I/O devices are accessed by reading and writing to specific memory locations. The CPU uses normal read- and write instructions to communicate with the devices. Each I/O device is given a specific address in the memory map of the device, and to save memory, only the specific I/O controllers used are clocked. This implies that the the I/O controller needs to be enabled before it can be used. Fortunately, the EFM32GG has a dedicated I/O controller for handling the different clocks, called the Clock Management Unit(CMU). A specific controller can be enabled by writing to the \emph CMU\_HFPERCLKEN0 register. This register consists of 32 bits where each bit corresponds to an I/O controller. 

To interface the gamepad to the EFM32GG, the GPIO pins are used. These pins are controlled through the GPIO controller. To enable an I/O controller, the value 1 is written to its corresponding register position. In case of enabling the GPIO clock position, bit 13 is set to 1. The following instructions gives an example how this can be achieved: 

\begin{lstlisting}
ldr r1, =CMU_BASE                //r1 = CMU_BASE
ldr r2, [r1, #CMU_HFPERCLKEN0]   //r2 = CMU_HFPERCLKEN0 

mov r3, #1                       //r3 = 1
lsl r3, r3, #CMU_HFPERCLKEN0_GPIO//Shift left 13 positions
orr r3, r2, r3                   //Enable the GPIO clock

str r2, [r1, #CMU_HFPERCLKEN0]   //Store the register back 
\end{lstlisting}

%Se mer p√•!!
\subsection{LED setup}

The GPIO pins are divided into several different ports on the EFM32GG-DK3750 development board. Each port corresponds to a different location in memory.  The pins are configured by writing to the $GPIO\_MODEL$ and $GPIO\_MODEH$ registers. These can be accessed by using their position relative to the GPIO base of the specific port. These registers contain 8-bit fields that can be used to configure the pins.  "$GPIO\_Px\_Model$ contains 8 bit fields named MODEn (n=0,1, .., 7) which controls pins 0-7 which controls pins 0-7, while $GPIO\_Px\_MODEH$ contains 8 bit fields named MODEn (n=8, 9, ..15) which controls pins 8-15." The different configurations can be found in \cite[p.758-759]{EFM32GG-rm}.    

In the case of the gamepad controller, the pins to the LEDs are connected to port A. These are assigned to output by writing {\emph 0x55555555} to  the $GPIO\_PA\_MODEH$ register. This corresponds to setting the pins 8-15 to an "open drain with pull-up" configuration\cite[p.758-759]{EFM32GG-rm}. As a result, the transistors connect to low, and the resistor connects to high. These are the specific configurations of the gamepad controller, and can be viewed in the schematics of the gamepad\cite{compendium}. Additionally, the drive strength of the pins are set to high. This is the current capabilities of the device. This is accomplished by writing 0x02 to the $GPIO\_PA\_CTRL$ register. Now, it is possible to toggle the LEDs by writing writing 0 to the upper level of the $GPIO\_PA\_DOUT$ registers. Note that the responds to active low signals. This can be seen by the gamepad schematics\cite{compendium}. The following instructions gives an example on how this can be achieved:


\begin{lstlisting}
ldr r1, =GPIO_PA_BASE        // r1 = GPIO_PA_BASE
ldr r2, =0x55555555          // r2 = 0x55555555  
str r2, [r1, #GPIO_MODEH]    //Store config
mov r2, #0x2                 // r2=0x02
str r2, [r1, #GPIO_PA_CTRL]  // GPIO_PA_CTRL=0x2                    

\end{lstlisting}


 

\subsection{Button setup}
The buttons are configured in a similar way to the configurations of the LEDs, with some minor differences. The pins are set to input by writing {\emph 0x33333333} to the $GPIO\_PC\_MODEL$ register. This corresponds to configuring each pin to "open drain with alternating drive strength"\cite[p.758-759]{EFM32GG-rm}. Then internal pull-up is enabled by writing 0xff to the $GPIO\_PC\_DOUT$ register. The state of the buttons can be seen by reading the $GPIO\_PC\_DIN$. An example of the configuration can be viewed in the following code snippet: 

\begin{lstlisting}
ldr r1, =GPIO_PC_BASE        //r1 = GPIO_PC_BASE
ldr r2, =0x33333333          //r2 = 0x33333333  
str r2, [r1, #GPIO_MODEL]    //Store config
mov r2, #0xff                // r2 = 0xff
str r2, [r1, #GPIO_DOUT]     // Internal pull-up

\end{lstlisting}





\subsection{Polling}\label{ch:polling}
The simplest way of communicating with an I/O device is what is known as busy waiting\cite[p. ]{wolf}. In this way, the CPU constantly checks the device to see if some register value has changed. In this context, the status of the buttons are checked by reading the button input registers. If the button is toggled, the program responds by writing a certain value to the LEDs. In the specific case of the gamepad used, this is accomplished by a loop continuously checking the $GPIO\_PC\_DIN$ register. If one of the bits in range 0-7 is set, the button is pushed. Note that a button is active low. An example of polling is provided in the following code snippet:

\begin{lstlisting}
     ldr r1, =GPIO_PC_BASE   // r1 = GPIO_PC_BASE
     ldr r2, =GPIO_PA_BASE   // r2 = GPIO_PA_BASE
while:
    ldr r3, [r1, #GPIO_DIN]  // r3 = GPIO_PC_DIN
    lsl r3, r3, #8           // r3 = shift left 8  
    str r3, [r2, #GPIO_DOUT] // GPIO_PA_DOUT = r3
    b while                  // loop
\end{lstlisting}

In this code example, the buttons are continuously polled. The result from each read-cycle is written to the $GPIO\_PA\_DOUT$ register. Since the buttons are located at the lower pins, and the buttons are located at the higher addresses, the value is shifted 8 positions to the left before it is written to the $GPIO\_PA\_DOUT$ register. 

\subsection{GPIO interrupts}\label{ch:interrupts}
The busy waiting approach is very inefficient, a lot of computational resources are wasted. A far better approach is to use interrupts. With interrupts the I/O controller itself are responsible of informing the CPU when changes has occurred. When interrupts occur I/O controller will send some information regarding what type of interrupt that has occurred. When the interrupt is handled by the CPU, the CPU stores all relevant state, and changes the flow of execution. The program counter is set to point to the relevant interrupt handler.  The interrupt handler contains the code that should run in case of an interrupt. 


In the EFM32GG with its ARM cortex-M3 processor contains an interrupt controller which can be used to enable and disable various interrupts. In the ARM cortex M3 micro processor this interrupt controller is known as the Nested Vectored Interrupt Controller(NVIC). This vector table contains the addresses of exception handlers and the Interrupt service routines (ISRs). In the ARM cortex M family of processors each Interrupt requests(IRQ) received has its own ISR. The starting address of each ISR is stored in an interrupt vector table. A lookup in the interrupt handler is performed overtime interrupt request is triggered. The interrupt table contains the service routines for interrupts. \cite{EFM32-int}. 

Interrupts can be enabled by writing to the \emph ISER0 and \emph ISER1 registers. These registers contain a bit for each interrupt source in the EFM32GG. An overview of the different interruption sources supported, and their respective bit positions, can be found in the EFM32GG references\cite[p.12-13]{EFM32GG-rm}. 

In the EFM32GG micro controller there are two interruption sources, GPIO\_ODD and GPIO\_EVEN, which handles enables interrupts for odd and even GPIO pins, respectively. These are located at positions 1 and 13 in the $ISER0$ register. Since it is not any point in distinguish between even and odd pins in this particular assignment. A better approach is to make sure both interrupt sources corresponds to the same interrupt handler. This can be accomplished by writing 0x802, which corresponds to enable the interrupts for even and odd numbers pins.

The registers $GPIO\_EXTIPSELL$ or $GPIO\_EXTIPSELH$ is used to select which port will trigger the interrupt flag. These registers are organized such that all the the pins with the same number are grouped together. The $GPIO\_EXTIPSELL$ is responsible for the pins ranging from 0 to 7, and $GPIO\_EXTIPSELH$ are responsible for the pins ranging from 8 to 15. In each of these registers 3-bits are used to specify which pin the should trigger the interrupt flag. An overview of the different configurations can be found in section 32.5.10 in the EFM32GG reference\cite{EFM32GG-rm}. In this particular case the pins are located at port C and the button pins are ranging from 0 to 7. Therefore, we write the value 0x22222222 to the $GPIO\_EXTIPSELL$ register.

In order to sense the interrupt flag, the registers $GPIO\_EXTRISE$ and/or $GPIO\_EXTFALL$ needs to be set. These registers enable sensing of rising and falling edges, respectively. These can be enabled by writing 0xff to both $GPIO\_EXTIFALL$ and $GPIO\_EXTIRISE$. To enable interrupt generation, 0xff is written to $GPIO\_IEN$. An example of setup interrupt for the GPIO pins are provided in the following code snippet: 

\begin{lstlisting}
ldr r1, =ISER0                //r1 = ISERO
ldr r2, =0x802                //r2 = 0x802  
str r2, r1                    //store pins

ldr r1, =GPIO_BASE            //r1 = GPIO_BASE
ldr r2, =0x222222222          //r2 = 0x222222222
str r2, [r1, #GPIO_EXTIPSELL] //store config

mov r2, 0xff                  //r2 = 0xff 
str r2, [r1, #GPIO_EXTIFALL]  //sense falling edge
str r2, [r1, #GPIO_EXTIRISE]  //sense rising edge
str r2, [r1, #GPIO_IEN]       //Enable interrupt handling 

\end{lstlisting}

When working with interrupts it is important to note that an interrupt flag is set. If not cleared, this flag, will cause the interrupt handler to be continuously called. In order to reset this flag the $GPIO\_IFC$ register need to be written. This register contains an overview of pending interrupts.(Cite here). An interrupt flag is reset by writing to its corresponding bit to 0.  The simplest way of achieving this is by by reading the $GPIO\_IF$ register, which is contains the source of the interrupt. By writing this value to the $GPIO\_IFC$ register the flag will be cleared.  This can be accomplished in the interrupt handler. The following code snip provide an example on how this can be achieved:

\begin{lstlisting}
ldr r1, =GPIO_BASE
ldr r2, [r1, #GPIO_IF]
str r2, [r2, GPIO_IFC]
\end{lstlisting}
 
{\bf need more cleanup}




\subsection{Energy modes}\label{ch:energy_modes} 
The EFM32GG micro controller has rich set of features regarding improving energy efficiency. For instance the EFM32GG contains several different energy levels. Where each level corresponds to some features being turned off. The main idea behind improving energy efficiency is turning of components that are not in use, or when they are not needed. However, it is also possible to modify the components themselves to use less energy. For instance, the clock manager is very powerful and allows the code to scale the clock to different frequencies. It is also possible to setup different clocks for different purposes. It is also possible to turn off parts of the RAM in order to improve energy efficiency. 

{\bf not enough details}


When waiting for an interrupt to occur there is really nothing going on in the system. This makes it possible to enter deep sleep mode during this time. There no point in wasting energy while waiting for interrupts, the processor is idle any way. In order to save this energy, EFM32GG allows the micro controller to enter energy mode very easily. The EFM32GG is still able to handle interrupts during this time. By entering deep sleep mode stops the high frequency oscillators and the HFPERCLK/HFCORECLK as well as the flash memory(cite EFM32GG side 30). During deep sleep mode it is possible to achieve energy consumption as low as, 900 nA(cite EFM32 energy efficiency page 2). The CPU will wake up when it receive an interrupt and go back to sleep when it is finished handling the interrupt. It is able to wake up in only 2micro seconds. (same cite). This is very beneficial when considering energy efficiency.   

Entering deep sleep mode can be achieved by writing to the System Control Register(SCR). This register contains to bits of particular interest: \emph DEEPSLEEP and \emph SLEEPONEXIT. When enable, the DEEPSLEEP bit allows the CPU to enter deep sleep mode. SLEEPONEXIT, when enabled, allows the CPU to enter deep sleep mode when finished handling an interrupt. Both bits can be set by writing the value 6 to the \emph SCR register. When the \emph SCR register is configured, deep sleep mode can be achieved by calling the \emph WFI instructions. This instruction causes immediate entry to sleep mode. 
