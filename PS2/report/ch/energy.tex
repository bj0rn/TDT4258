The EFM32GG microcontroller has a rich set of features regarding improving energy efficiency, where the main focus is turing of components that are not in use, or tuning their performance. In case of this assignment, we have utilised many of these techniques to improve the power consumption of the program. Where our main goal has been trying to exploit the various energy levels that the microcontroller had to offer. Preferable being able to achieve EM2, and turn of every component currently not being used. 

Various techniques were employed to reach this goal. As it turned out the achieving deep sleep and sleep on exit proved to be more complicated than first imagined. During deep sleep mode the high frequency oscillator was turned off. This oscillator was used to clock both the DAC and the timer. When entering EFM32 this produced some unexpected bugs. On entering EM2 the program started to behave non-deterministic. As it turned out, both the DAC and the timer was clocked by the high frequency oscillator. This directly affected the interrupts produced by the timer.

This problem was solved by introducing the low energy timer. This timer is able to run as low as to EM2 and EM3 depending on the oscillator used. In case of producing sound, the 32 KHz oscillator were used. This timer replaced the old timer, and only caused some minor changes to made in the already existing code. In particular, the frequency used to generated was changed to accommodate the new oscillator frequency. Instead of 48000 interrupts every second, the new oscillator were able to produce 32768 interrupts every second. The code used to enable the low energy timer can be viewed below.  


\begin{lstlisting}
void setupLowEnergyTimer(){
    *CMU_OSCENCMD = (1 << 6); /* Enable the low frequency oscillator*/
    *CMU_HFCORECLKEN0 |= (1 << 4); /* Enable LE clock*/
    *LETIMER0_CTRL |= (1 << 9); /* Set COMP0 as top register*/
    *CMU_LFACLKEN0 |= (1 << 2); /* Enable low energy timer0*/
    *LETIMER0_TOP = 1;  /* Set TOP to 1 */
    *LETIMER0_IEN = 1;  /* Enable interrupts */ 
    *LETIMER0_CMD = 1;  /* Start the timer */
}

\end{lstlisting}




This produced a lower energy consumption, however DAC still caused problems. Since the DAC were configured to continuously pull the DAC registers. The were some problems when entering the low energy mode. The entering of energy mode caused the DAC to continue producing static sound. As it turns out, configuring the DAC with continuous mode will not be able to maintain the voltage levels when entering deep sleep. Continuous mode does not use any kind of refresh on conversions \cite{EFM32GG-rm}. This cause the voltage levels to fluctuate, and create a static background sound. Fortunately, the DAC also support another mode, sample/hold mode. During sample/hold mode, the DAC core converts on a triggered conversion and then holds the output in a sample/hold element. When not converting, the DAC is turned of between sample, which reduces the power consumption. The sample/hold element will hold the element for a certain time without a refresh conversion\cite{EFM32GG-rm}. Fortunately, this holding time is sufficient in order to fix our bug, and on the same time further decrease the energy consumption. This change from continuous mode to sample/hold mode is achieved by changing the value written to the $DAC0\_CTRL$ register. This can be seen in the code listing below. 


\begin{lstlisting}
void setupDAC(){
    /*...*/
    *DAC_CTRL0 = 0x50010;   /*The old value*/
    *DAC_CTRL0 = 0x50014;   /*The new value enabling hold/sample mode*/
    /*...*/
}
\end{lstlisting}


   



  
       

 



