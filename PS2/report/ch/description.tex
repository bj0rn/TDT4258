\section{Description And Methodology}


\subsection{Initial Setup}
To begin with, peripherals such as buttons, LEDs, DAC, and timers needed to be configured. As C programs can control hardware directly, one only needs to use pointers to refer to memory-mapped I/O registers. A lot of these were provided in the efm32gg.h-file where many of the registers were defined with macros by using volatile $uint32\_t$ pointer variables, so in the initial setup it was simply a matter of dereferencing these and writing the appropriate values.


\subsubsection{Interrupt handlers}
The procedure for setting up interrupt handlers will vary depending on the hardware used. To enable interrupt generation and interrupt handling for the appropriate exception handlers, the proper value had to be written to the ISER0-register, which was done in the setupNVIC()-function. The code for enabling interrupts for the GPIO-pins (odd and even) and TIMER1 was as follows.

\begin{lstlisting}

void setupNVIC()
{
 	*ISER0 = 0x1802; /*Enable interrupt handling for odd and even GPIO pins and TIMER1*/
}

\end{lstlisting} 
This hexadecimal value corresponds to writing bit 1, 11, and 12 in the register, which are the appropriate bits for enabling interrupts for the mentioned exception handlers.

The code for the exception vectors was already filled out in the startup code, so all that needed to be done to use the exception handlers was to write a function in the form $\_\_attribute\_\_$ ((interrupt)), as this tells the compiler that this is a function used for exception handling.


\subsubsection{Timers}
There are several hardware timers that can be used, depending on the purpose (calculation-intensive operations, low energy demands, etc...). The timers have the advantage of being able to produce interrupts at periodic intervals. These makes them ideal when working with sounds where the creations of sound waves depends consistent oscillations. 

The timer were configured to be set to an specific frequency through the use of the TOP register. The interrupt frequency was determined by dividing the timer clock frequency by the amount of interrupts required. The TOP register specifies the number of clock cycles between each interrupt


\subsubsection{Digital to analog converter (DAC)}

The EFM32GG has several modes of writing to the DAC, with continous mode being the simplest one. How to set up the DAC in this mode was well specified in the compendium, and was implemented as a C function in the following way:

\begin{lstlisting}

void setupDAC()
{
  	*CMU_HFPERCLKEN0 |= (1 << 17); /*Enable DAC clock */
	*DAC0_CTRL = 0x50010; /*Prescale clock to yield 437.5 KHz and enables DAC output to the amplified */
	*DAC0_CH0CTRL = 1; /*Enable left channel */
	*DAC0_CH1CTRL = 1; /*Enable right channel */
}

\end{lstlisting}

Writing 0x50010 to the $DAC0\_CTRL$ register also enables DAC-output in continous mode. As we learned later, altering  this value to, for instance, 0x50014, will enable the DAC-output to sample/hold mode instead of continous mode. This will be explained in greater detail in the Energy Optimization section.

\subsection{Sound Wave Synthesis}

Sound is realised through sound waves which is created by oscillations. "An oscillator generates a consistent, repeating signals". These consistent signals can be used to create waves at various frequencies. Sound is actually the properties of the waves generated, with respect to frequency, amplitude, and period. The frequency determines the tone of the sound, the amplitude the strength, and the period the duration of the sound.

There are various different approaches for generating these sound waves. The different waves have slightly different properties in regard to sound. To name a few different waves we have the sine wave, sawtooth wave, triangle wave and the square wave. These waves produces different sound characteristics. For instance, an ideal square wave will make instantaneous transitions between high and low levels, whereas a sawtooth wave will "climb" to the highest amplitude level, then instantaneously drop down to its lowest level. These two waves are illustrated in the figures below.{\bf more on this ? Sources and shit like that}. 

\input{fig/square.tex}
\input{fig/sawtooth.tex}

The waves shown above are the two types we have created in this assignment. The square wave is created by calculating discrete samples based on the tone frequency and the oscillator frequency. Oscillator frequency divided by the tone frequency decides how often the values to the DAC should alternate, thereby producing an approximation of the note. The different notes supported by the program is as follows, A, B, C, D, E, F, G, and H.


\subsection{Sound Sampling}
\input{ch/sound-sampling}




\subsection{Energy Optimization}
\input{ch/energy}



\subsection{User Control}
\input{UserControl}











